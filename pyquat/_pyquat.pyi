from typing import Any, Optional, overload
import numpy as np
import numpy.typing as npt


class Quat:
    @classmethod
    def from_rotation_vector(cls, mat: npt.ArrayLike) -> Quat: ...

    @classmethod
    def from_matrix(cls, mat: npt.ArrayLike) -> Quat: ...

    def __init__(self, scalar: float, vx: float, vy: float, vz: float) -> None: ...
    def __repr__(self) -> str: ...
    def __mul__(self, other: Quat) -> Quat: ...
    def rotate(self, vec: npt.ArrayLike) -> np.ndarray[Any, np.dtype[np.float64]]: ...
    def normalize(self) -> Quat: ...
    def normalize_large(self) -> Quat: ...
    def normalized(self) -> Quat: ...
    def normalized_large(self) -> Quat: ...
    def conjugated(self) -> Quat: ...
    def copy(self) -> Quat: ...
    def tobytes(self) -> bytes: ...
    def lerp(self, rhs: Quat, t: float, lerp_threshold: Optional[float] = 1.0) -> Quat: ...
    def slerp(self, rhs: Quat, t: float, lerp_threshold: Optional[float] = 1.0) -> Quat: ...
    def dot(self, other: Quat) -> float: ...

    def to_vector(self) -> np.ndarray[Any, np.dtype[np.float64]]: ...
    def to_angle_vector(self) -> np.ndarray[Any, np.dtype[np.float64]]: ...


def big_omega(w: npt.ArrayLike) -> np.ndarray[Any, np.dtype[np.float64]]: ...
def skew(w: npt.ArrayLike) -> np.ndarray[Any, np.dtype[np.float64]]: ...
def valenti_q_mag(ary: npt.ArrayLike) -> Quat: ...
def valenti_dq_mag(ary: npt.ArrayLike) -> Quat: ...
def valenti_q_acc(ary: npt.ArrayLike) -> Quat: ...
def valenti_dq_acc(ary: npt.ArrayLike) -> Quat: ...

def expm(ary: npt.ArrayLike, t: float) -> np.ndarray[Any, np.dtype[np.float64]]: ...

